{
  "version": 3,
  "sources": ["../../.pnpm/cookie-es@1.2.2/node_modules/cookie-es/dist/index.mjs", "../../.pnpm/@tanstack+router-core@1.128.8/node_modules/@tanstack/router-core/src/ssr/headers.ts", "../../.pnpm/@tanstack+router-core@1.128.8/node_modules/@tanstack/router-core/src/ssr/json.ts", "../../.pnpm/@tanstack+router-core@1.128.8/node_modules/@tanstack/router-core/src/ssr/ssr-client.ts", "../../.pnpm/@tanstack+start-client-core@1.128.8/node_modules/@tanstack/start-client-core/src/serializer.ts", "../../.pnpm/@tanstack+start-client-core@1.128.8/node_modules/@tanstack/start-client-core/src/createIsomorphicFn.ts", "../../.pnpm/@tanstack+start-client-core@1.128.8/node_modules/@tanstack/start-client-core/src/envOnly.ts", "../../.pnpm/@tanstack+start-client-core@1.128.8/node_modules/@tanstack/start-client-core/src/registerGlobalMiddleware.ts", "../../.pnpm/@tanstack+start-client-core@1.128.8/node_modules/@tanstack/start-client-core/src/createServerFn.ts", "../../.pnpm/@tanstack+start-client-core@1.128.8/node_modules/@tanstack/start-client-core/src/createMiddleware.ts", "../../.pnpm/@tanstack+react-start-client@1.128.8_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@tanstack/react-start-client/src/Meta.tsx", "../../.pnpm/@tanstack+react-start-client@1.128.8_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@tanstack/react-start-client/src/Scripts.tsx", "../../.pnpm/@tanstack+react-start-client@1.128.8_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@tanstack/react-start-client/src/StartClient.tsx", "../../.pnpm/@tanstack+react-start-client@1.128.8_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@tanstack/react-start-client/src/renderRSC.tsx", "../../.pnpm/@tanstack+react-start-client@1.128.8_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/@tanstack/react-start-client/src/useServerFn.ts"],
  "sourcesContent": ["function parse(str, options) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  const obj = {};\n  const opt = options || {};\n  const dec = opt.decode || decode;\n  let index = 0;\n  while (index < str.length) {\n    const eqIdx = str.indexOf(\"=\", index);\n    if (eqIdx === -1) {\n      break;\n    }\n    let endIdx = str.indexOf(\";\", index);\n    if (endIdx === -1) {\n      endIdx = str.length;\n    } else if (endIdx < eqIdx) {\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n    const key = str.slice(index, eqIdx).trim();\n    if (opt?.filter && !opt?.filter(key)) {\n      index = endIdx + 1;\n      continue;\n    }\n    if (void 0 === obj[key]) {\n      let val = str.slice(eqIdx + 1, endIdx).trim();\n      if (val.codePointAt(0) === 34) {\n        val = val.slice(1, -1);\n      }\n      obj[key] = tryDecode(val, dec);\n    }\n    index = endIdx + 1;\n  }\n  return obj;\n}\nfunction decode(str) {\n  return str.includes(\"%\") ? decodeURIComponent(str) : str;\n}\nfunction tryDecode(str, decode2) {\n  try {\n    return decode2(str);\n  } catch {\n    return str;\n  }\n}\n\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]+$/;\nfunction serialize(name, value, options) {\n  const opt = options || {};\n  const enc = opt.encode || encodeURIComponent;\n  if (typeof enc !== \"function\") {\n    throw new TypeError(\"option encode is invalid\");\n  }\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError(\"argument name is invalid\");\n  }\n  const encodedValue = enc(value);\n  if (encodedValue && !fieldContentRegExp.test(encodedValue)) {\n    throw new TypeError(\"argument val is invalid\");\n  }\n  let str = name + \"=\" + encodedValue;\n  if (void 0 !== opt.maxAge && opt.maxAge !== null) {\n    const maxAge = opt.maxAge - 0;\n    if (Number.isNaN(maxAge) || !Number.isFinite(maxAge)) {\n      throw new TypeError(\"option maxAge is invalid\");\n    }\n    str += \"; Max-Age=\" + Math.floor(maxAge);\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError(\"option domain is invalid\");\n    }\n    str += \"; Domain=\" + opt.domain;\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError(\"option path is invalid\");\n    }\n    str += \"; Path=\" + opt.path;\n  }\n  if (opt.expires) {\n    if (!isDate(opt.expires) || Number.isNaN(opt.expires.valueOf())) {\n      throw new TypeError(\"option expires is invalid\");\n    }\n    str += \"; Expires=\" + opt.expires.toUTCString();\n  }\n  if (opt.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    str += \"; Secure\";\n  }\n  if (opt.priority) {\n    const priority = typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n    switch (priority) {\n      case \"low\": {\n        str += \"; Priority=Low\";\n        break;\n      }\n      case \"medium\": {\n        str += \"; Priority=Medium\";\n        break;\n      }\n      case \"high\": {\n        str += \"; Priority=High\";\n        break;\n      }\n      default: {\n        throw new TypeError(\"option priority is invalid\");\n      }\n    }\n  }\n  if (opt.sameSite) {\n    const sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true: {\n        str += \"; SameSite=Strict\";\n        break;\n      }\n      case \"lax\": {\n        str += \"; SameSite=Lax\";\n        break;\n      }\n      case \"strict\": {\n        str += \"; SameSite=Strict\";\n        break;\n      }\n      case \"none\": {\n        str += \"; SameSite=None\";\n        break;\n      }\n      default: {\n        throw new TypeError(\"option sameSite is invalid\");\n      }\n    }\n  }\n  if (opt.partitioned) {\n    str += \"; Partitioned\";\n  }\n  return str;\n}\nfunction isDate(val) {\n  return Object.prototype.toString.call(val) === \"[object Date]\" || val instanceof Date;\n}\n\nfunction parseSetCookie(setCookieValue, options) {\n  const parts = (setCookieValue || \"\").split(\";\").filter((str) => typeof str === \"string\" && !!str.trim());\n  const nameValuePairStr = parts.shift() || \"\";\n  const parsed = _parseNameValuePair(nameValuePairStr);\n  const name = parsed.name;\n  let value = parsed.value;\n  try {\n    value = options?.decode === false ? value : (options?.decode || decodeURIComponent)(value);\n  } catch {\n  }\n  const cookie = {\n    name,\n    value\n  };\n  for (const part of parts) {\n    const sides = part.split(\"=\");\n    const partKey = (sides.shift() || \"\").trimStart().toLowerCase();\n    const partValue = sides.join(\"=\");\n    switch (partKey) {\n      case \"expires\": {\n        cookie.expires = new Date(partValue);\n        break;\n      }\n      case \"max-age\": {\n        cookie.maxAge = Number.parseInt(partValue, 10);\n        break;\n      }\n      case \"secure\": {\n        cookie.secure = true;\n        break;\n      }\n      case \"httponly\": {\n        cookie.httpOnly = true;\n        break;\n      }\n      case \"samesite\": {\n        cookie.sameSite = partValue;\n        break;\n      }\n      default: {\n        cookie[partKey] = partValue;\n      }\n    }\n  }\n  return cookie;\n}\nfunction _parseNameValuePair(nameValuePairStr) {\n  let name = \"\";\n  let value = \"\";\n  const nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\");\n  } else {\n    value = nameValuePairStr;\n  }\n  return { name, value };\n}\n\nfunction splitSetCookieString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString.flatMap((c) => splitSetCookieString(c));\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n  const cookiesStrings = [];\n  let pos = 0;\n  let start;\n  let ch;\n  let lastComma;\n  let nextStart;\n  let cookiesSeparatorFound;\n  const skipWhitespace = () => {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  };\n  const notSpecialChar = () => {\n    ch = cookiesString.charAt(pos);\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  };\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        lastComma = pos;\n        pos += 1;\n        skipWhitespace();\n        nextStart = pos;\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          cookiesSeparatorFound = true;\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.slice(start, lastComma));\n          start = pos;\n        } else {\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.slice(start, cookiesString.length));\n    }\n  }\n  return cookiesStrings;\n}\n\nexport { parse, parseSetCookie, serialize, splitSetCookieString };\n", "import { splitSetCookieString } from 'cookie-es'\nimport type { OutgoingHttpHeaders } from 'node:http2'\n\n// A utility function to turn HeadersInit into an object\nexport function headersInitToObject(\n  headers: HeadersInit,\n): Record<keyof OutgoingHttpHeaders, string> {\n  const obj: Record<keyof OutgoingHttpHeaders, string> = {}\n  const headersInstance = new Headers(headers)\n  for (const [key, value] of headersInstance.entries()) {\n    obj[key] = value\n  }\n  return obj\n}\n\ntype AnyHeaders =\n  | Headers\n  | HeadersInit\n  | Record<string, string>\n  | Array<[string, string]>\n  | OutgoingHttpHeaders\n  | undefined\n\n// Helper function to convert various HeaderInit types to a Headers instance\nfunction toHeadersInstance(init: AnyHeaders) {\n  if (init instanceof Headers) {\n    return new Headers(init)\n  } else if (Array.isArray(init)) {\n    return new Headers(init)\n  } else if (typeof init === 'object') {\n    return new Headers(init as HeadersInit)\n  } else {\n    return new Headers()\n  }\n}\n\n// Function to merge headers with proper overrides\nexport function mergeHeaders(...headers: Array<AnyHeaders>) {\n  return headers.reduce((acc: Headers, header) => {\n    const headersInstance = toHeadersInstance(header)\n    for (const [key, value] of headersInstance.entries()) {\n      if (key === 'set-cookie') {\n        const splitCookies = splitSetCookieString(value)\n        splitCookies.forEach((cookie) => acc.append('set-cookie', cookie))\n      } else {\n        acc.set(key, value)\n      }\n    }\n    return acc\n  }, new Headers())\n}\n", "import { mergeHeaders } from './headers'\n\nexport interface JsonResponse<TData> extends Response {\n  json: () => Promise<TData>\n}\n\nexport function json<TData>(\n  payload: TData,\n  init?: ResponseInit,\n): JsonResponse<TData> {\n  return new Response(JSON.stringify(payload), {\n    ...init,\n    headers: mergeHeaders(\n      { 'content-type': 'application/json' },\n      init?.headers,\n    ),\n  })\n}\n", "import invariant from 'tiny-invariant'\nimport { batch } from '@tanstack/store'\nimport { createControlledPromise } from '../utils'\nimport type { AnyRouteMatch, MakeRouteMatch } from '../Matches'\nimport type { AnyRouter } from '../router'\nimport type { Manifest } from '../manifest'\nimport type { RouteContextOptions } from '../route'\nimport type { GLOBAL_TSR } from './ssr-server'\n\ndeclare global {\n  interface Window {\n    [GLOBAL_TSR]?: TsrSsrGlobal\n  }\n}\n\nexport interface TsrSsrGlobal {\n  router?: DehydratedRouter\n  // clean scripts, shortened since this is sent for each streamed script\n  c: () => void\n}\n\nfunction hydrateMatch(\n  deyhydratedMatch: DehydratedMatch,\n): Partial<MakeRouteMatch> {\n  return {\n    id: deyhydratedMatch.i,\n    __beforeLoadContext: deyhydratedMatch.b,\n    loaderData: deyhydratedMatch.l,\n    status: deyhydratedMatch.s,\n    ssr: deyhydratedMatch.ssr,\n    updatedAt: deyhydratedMatch.u,\n    error: deyhydratedMatch.e,\n  }\n}\nexport interface DehydratedMatch {\n  i: MakeRouteMatch['id']\n  b?: MakeRouteMatch['__beforeLoadContext']\n  l?: MakeRouteMatch['loaderData']\n  e?: MakeRouteMatch['error']\n  u: MakeRouteMatch['updatedAt']\n  s: MakeRouteMatch['status']\n  ssr?: MakeRouteMatch['ssr']\n}\n\nexport interface DehydratedRouter {\n  manifest: Manifest | undefined\n  dehydratedData?: any\n  lastMatchId?: string\n  matches: Array<DehydratedMatch>\n}\n\nexport async function hydrate(router: AnyRouter): Promise<any> {\n  invariant(\n    window.$_TSR?.router,\n    'Expected to find a dehydrated data on window.$_TSR.router, but we did not. Please file an issue!',\n  )\n\n  const { manifest, dehydratedData, lastMatchId } = window.$_TSR.router\n\n  router.ssr = {\n    manifest,\n  }\n\n  // Hydrate the router state\n  const matches = router.matchRoutes(router.state.location)\n\n  // kick off loading the route chunks\n  const routeChunkPromise = Promise.all(\n    matches.map((match) => {\n      const route = router.looseRoutesById[match.routeId]!\n      return router.loadRouteChunk(route)\n    }),\n  )\n\n  function setMatchForcePending(match: AnyRouteMatch) {\n    // usually the minPendingPromise is created in the Match component if a pending match is rendered\n    // however, this might be too late if the match synchronously resolves\n    const route = router.looseRoutesById[match.routeId]!\n    const pendingMinMs =\n      route.options.pendingMinMs ?? router.options.defaultPendingMinMs\n    if (pendingMinMs) {\n      const minPendingPromise = createControlledPromise<void>()\n      match.minPendingPromise = minPendingPromise\n      match._forcePending = true\n\n      setTimeout(() => {\n        minPendingPromise.resolve()\n        // We've handled the minPendingPromise, so we can delete it\n        router.updateMatch(match.id, (prev) => ({\n          ...prev,\n          minPendingPromise: undefined,\n          _forcePending: undefined,\n        }))\n      }, pendingMinMs)\n    }\n  }\n\n  // Right after hydration and before the first render, we need to rehydrate each match\n  // First step is to reyhdrate loaderData and __beforeLoadContext\n  let firstNonSsrMatchIndex: number | undefined = undefined\n  matches.forEach((match) => {\n    const dehydratedMatch = window.$_TSR!.router!.matches.find(\n      (d) => d.i === match.id,\n    )\n    if (!dehydratedMatch) {\n      Object.assign(match, { dehydrated: false, ssr: false })\n      return\n    }\n\n    Object.assign(match, hydrateMatch(dehydratedMatch))\n\n    if (match.ssr === false) {\n      match._dehydrated = false\n    } else {\n      match._dehydrated = true\n    }\n\n    if (match.ssr === 'data-only' || match.ssr === false) {\n      if (firstNonSsrMatchIndex === undefined) {\n        firstNonSsrMatchIndex = match.index\n        setMatchForcePending(match)\n      }\n    }\n  })\n\n  router.__store.setState((s) => {\n    return {\n      ...s,\n      matches,\n    }\n  })\n\n  // Allow the user to handle custom hydration data\n  await router.options.hydrate?.(dehydratedData)\n\n  // now that all necessary data is hydrated:\n  // 1) fully reconstruct the route context\n  // 2) execute `head()` and `scripts()` for each match\n  await Promise.all(\n    router.state.matches.map(async (match) => {\n      const route = router.looseRoutesById[match.routeId]!\n\n      const parentMatch = router.state.matches[match.index - 1]\n      const parentContext = parentMatch?.context ?? router.options.context ?? {}\n\n      // `context()` was already executed by `matchRoutes`, however route context was not yet fully reconstructed\n      // so run it again and merge route context\n      const contextFnContext: RouteContextOptions<any, any, any, any> = {\n        deps: match.loaderDeps,\n        params: match.params,\n        context: parentContext,\n        location: router.state.location,\n        navigate: (opts: any) =>\n          router.navigate({ ...opts, _fromLocation: router.state.location }),\n        buildLocation: router.buildLocation,\n        cause: match.cause,\n        abortController: match.abortController,\n        preload: false,\n        matches,\n      }\n      match.__routeContext = route.options.context?.(contextFnContext) ?? {}\n\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext,\n      }\n\n      const assetContext = {\n        matches: router.state.matches,\n        match,\n        params: match.params,\n        loaderData: match.loaderData,\n      }\n      const headFnContent = await route.options.head?.(assetContext)\n\n      const scripts = await route.options.scripts?.(assetContext)\n\n      match.meta = headFnContent?.meta\n      match.links = headFnContent?.links\n      match.headScripts = headFnContent?.scripts\n      match.styles = headFnContent?.styles\n      match.scripts = scripts\n    }),\n  )\n\n  const isSpaMode = matches[matches.length - 1]!.id !== lastMatchId\n  const hasSsrFalseMatches = matches.some((m) => m.ssr === false)\n  // all matches have data from the server   and we are not in SPA mode so we don't need to kick of router.load()\n  if (!hasSsrFalseMatches && !isSpaMode) {\n    matches.forEach((match) => {\n      // remove the _dehydrate flag since we won't run router.load() which would remove it\n      match._dehydrated = undefined\n    })\n    return routeChunkPromise\n  }\n\n  // schedule router.load() to run after the next tick so we can store the promise in the match before loading starts\n  const loadPromise = Promise.resolve()\n    .then(() => router.load())\n    .catch((err) => {\n      console.error('Error during router hydration:', err)\n    })\n\n  // in SPA mode we need to keep the first match below the root route pending until router.load() is finished\n  // this will prevent that other pending components are rendered but hydration is not blocked\n  if (isSpaMode) {\n    const match = matches[1]\n    invariant(\n      match,\n      'Expected to find a match below the root match in SPA mode.',\n    )\n    setMatchForcePending(match)\n\n    match._displayPending = true\n    match.displayPendingPromise = loadPromise\n\n    loadPromise.then(() => {\n      batch(() => {\n        // ensure router is not in status 'pending' anymore\n        // this usually happens in Transitioner but if loading synchronously resolves,\n        // Transitioner won't be rendered while loading so it cannot track the change from loading:true to loading:false\n        if (router.__store.state.status === 'pending') {\n          router.__store.setState((s) => ({\n            ...s,\n            status: 'idle',\n            resolvedLocation: s.location,\n          }))\n        }\n        // hide the pending component once the load is finished\n        router.updateMatch(match.id, (prev) => {\n          return {\n            ...prev,\n            _displayPending: undefined,\n            displayPendingPromise: undefined,\n          }\n        })\n      })\n    })\n  }\n  return routeChunkPromise\n}\n", "import { isPlainObject } from '@tanstack/router-core'\n\nexport interface StartSerializer {\n  stringify: (obj: unknown) => string\n  parse: (str: string) => unknown\n  encode: <T>(value: T) => T\n  decode: <T>(value: T) => T\n}\n\nexport type SerializerStringifyBy<T, TSerializable> = T extends TSerializable\n  ? T\n  : T extends (...args: Array<any>) => any\n    ? 'Function is not serializable'\n    : { [K in keyof T]: SerializerStringifyBy<T[K], TSerializable> }\n\nexport type SerializerParseBy<T, TSerializable> = T extends TSerializable\n  ? T\n  : unknown extends SerializerExtensions['ReadableStream']\n    ? { [K in keyof T]: SerializerParseBy<T[K], TSerializable> }\n    : T extends SerializerExtensions['ReadableStream']\n      ? ReadableStream\n      : { [K in keyof T]: SerializerParseBy<T[K], TSerializable> }\n\nexport interface DefaultSerializerExtensions {\n  ReadableStream: unknown\n}\n\nexport interface SerializerExtensions extends DefaultSerializerExtensions {}\n\nexport type Serializable = Date | undefined | Error | FormData | bigint\n\nexport type SerializerStringify<T> = SerializerStringifyBy<T, Serializable>\n\nexport type SerializerParse<T> = SerializerParseBy<T, Serializable>\nexport const startSerializer: StartSerializer = {\n  stringify: (value: any) =>\n    JSON.stringify(value, function replacer(key, val) {\n      const ogVal = this[key]\n      const serializer = serializers.find((t) => t.stringifyCondition(ogVal))\n\n      if (serializer) {\n        return serializer.stringify(ogVal)\n      }\n\n      return val\n    }),\n  parse: (value: string) =>\n    JSON.parse(value, function parser(key, val) {\n      const ogVal = this[key]\n      if (isPlainObject(ogVal)) {\n        const serializer = serializers.find((t) => t.parseCondition(ogVal))\n\n        if (serializer) {\n          return serializer.parse(ogVal)\n        }\n      }\n\n      return val\n    }),\n  encode: (value: any) => {\n    // When encoding, dive first\n    if (Array.isArray(value)) {\n      return value.map((v) => startSerializer.encode(v))\n    }\n\n    if (isPlainObject(value)) {\n      return Object.fromEntries(\n        Object.entries(value).map(([key, v]) => [\n          key,\n          startSerializer.encode(v),\n        ]),\n      )\n    }\n\n    const serializer = serializers.find((t) => t.stringifyCondition(value))\n    if (serializer) {\n      return serializer.stringify(value)\n    }\n\n    return value\n  },\n  decode: (value: any) => {\n    // Attempt transform first\n    if (isPlainObject(value)) {\n      const serializer = serializers.find((t) => t.parseCondition(value))\n      if (serializer) {\n        return serializer.parse(value)\n      }\n    }\n\n    if (Array.isArray(value)) {\n      return value.map((v) => startSerializer.decode(v))\n    }\n\n    if (isPlainObject(value)) {\n      return Object.fromEntries(\n        Object.entries(value).map(([key, v]) => [\n          key,\n          startSerializer.decode(v),\n        ]),\n      )\n    }\n\n    return value\n  },\n}\nconst createSerializer = <TKey extends string, TInput, TSerialized>(\n  key: TKey,\n  check: (value: any) => value is TInput,\n  toValue: (value: TInput) => TSerialized,\n  fromValue: (value: TSerialized) => TInput,\n) => ({\n  key,\n  stringifyCondition: check,\n  stringify: (value: any) => ({ [`$${key}`]: toValue(value) }),\n  parseCondition: (value: any) => Object.hasOwn(value, `$${key}`),\n  parse: (value: any) => fromValue(value[`$${key}`]),\n})\n// Keep these ordered by predicted frequency\n// Make sure to keep DefaultSerializable in sync with these serializers\n// Also, make sure that they are unit tested in serializer.test.tsx\nconst serializers = [\n  createSerializer(\n    // Key\n    'undefined',\n    // Check\n    (v): v is undefined => v === undefined,\n    // To\n    () => 0,\n    // From\n    () => undefined,\n  ),\n  createSerializer(\n    // Key\n    'date',\n    // Check\n    (v): v is Date => v instanceof Date,\n    // To\n    (v) => v.toISOString(),\n    // From\n    (v) => new Date(v),\n  ),\n  createSerializer(\n    // Key\n    'error',\n    // Check\n    (v): v is Error => v instanceof Error,\n    // To\n    (v) => ({\n      ...v,\n      message: v.message,\n      stack: process.env.NODE_ENV === 'development' ? v.stack : undefined,\n      cause: v.cause,\n    }),\n    // From\n    (v) => Object.assign(new Error(v.message), v),\n  ),\n  createSerializer(\n    // Key\n    'formData',\n    // Check\n    (v): v is FormData => v instanceof FormData,\n    // To\n    (v) => {\n      const entries: Record<\n        string,\n        Array<FormDataEntryValue> | FormDataEntryValue\n      > = {}\n      v.forEach((value, key) => {\n        const entry = entries[key]\n        if (entry !== undefined) {\n          if (Array.isArray(entry)) {\n            entry.push(value)\n          } else {\n            entries[key] = [entry, value]\n          }\n        } else {\n          entries[key] = value\n        }\n      })\n      return entries\n    },\n    // From\n    (v) => {\n      const formData = new FormData()\n      Object.entries(v).forEach(([key, value]) => {\n        if (Array.isArray(value)) {\n          value.forEach((val) => formData.append(key, val))\n        } else {\n          formData.append(key, value)\n        }\n      })\n      return formData\n    },\n  ),\n  createSerializer(\n    // Key\n    'bigint',\n    // Check\n    (v): v is bigint => typeof v === 'bigint',\n    // To\n    (v) => v.toString(),\n    // From\n    (v) => BigInt(v),\n  ),\n] as const\n", "// a function that can have different implementations on the client and server.\n// implementations not provided will default to a no-op function.\n\nexport type IsomorphicFn<\n  TArgs extends Array<any> = [],\n  TServer = undefined,\n  TClient = undefined,\n> = (...args: TArgs) => TServer | TClient\n\nexport interface ServerOnlyFn<TArgs extends Array<any>, TServer>\n  extends IsomorphicFn<TArgs, TServer> {\n  client: <TClient>(\n    clientImpl: (...args: TArgs) => TClient,\n  ) => IsomorphicFn<TArgs, TServer, TClient>\n}\n\nexport interface ClientOnlyFn<TArgs extends Array<any>, TClient>\n  extends IsomorphicFn<TArgs, undefined, TClient> {\n  server: <TServer>(\n    serverImpl: (...args: TArgs) => TServer,\n  ) => IsomorphicFn<TArgs, TServer, TClient>\n}\n\nexport interface IsomorphicFnBase extends IsomorphicFn {\n  server: <TArgs extends Array<any>, TServer>(\n    serverImpl: (...args: TArgs) => TServer,\n  ) => ServerOnlyFn<TArgs, TServer>\n  client: <TArgs extends Array<any>, TClient>(\n    clientImpl: (...args: TArgs) => TClient,\n  ) => ClientOnlyFn<TArgs, TClient>\n}\n\n// this is a dummy function, it will be replaced by the transformer\nexport function createIsomorphicFn(): IsomorphicFnBase {\n  return null!\n}\n", "type EnvOnlyFn = <TFn extends (...args: Array<any>) => any>(fn: TFn) => TFn\n\n// A function that will only be available in the server build\n// If called on the client, it will throw an error\nexport const serverOnly: EnvOnlyFn = (fn) => fn\n\n// A function that will only be available in the client build\n// If called on the server, it will throw an error\nexport const clientOnly: EnvOnlyFn = (fn) => fn\n", "import type { AnyFunctionMiddleware } from './createMiddleware'\n\nexport const globalMiddleware: Array<AnyFunctionMiddleware> = []\n\nexport function registerGlobalMiddleware(options: {\n  middleware: Array<AnyFunctionMiddleware>\n}) {\n  globalMiddleware.push(...options.middleware)\n}\n", "import { default as invariant } from 'tiny-invariant'\nimport { default as warning } from 'tiny-warning'\nimport { isNotFound, isRedirect } from '@tanstack/router-core'\nimport { mergeHeaders } from '@tanstack/router-core/ssr/client'\nimport { globalMiddleware } from './registerGlobalMiddleware'\n\nimport { startSerializer } from './serializer'\nimport type {\n  SerializerParse,\n  SerializerStringify,\n  SerializerStringifyBy,\n} from './serializer'\nimport type {\n  AnyValidator,\n  Constrain,\n  Expand,\n  ResolveValidatorInput,\n  Validator,\n} from '@tanstack/router-core'\nimport type { JsonResponse } from '@tanstack/router-core/ssr/client'\nimport type { Readable } from 'node:stream'\nimport type {\n  AnyFunctionMiddleware,\n  AssignAllClientSendContext,\n  AssignAllServerContext,\n  FunctionMiddlewareClientFnResult,\n  FunctionMiddlewareServerFnResult,\n  IntersectAllValidatorInputs,\n  IntersectAllValidatorOutputs,\n} from './createMiddleware'\n\ntype TODO = any\n\nexport function createServerFn<\n  TMethod extends Method,\n  TServerFnResponseType extends ServerFnResponseType = 'data',\n  TResponse = unknown,\n  TMiddlewares = undefined,\n  TValidator = undefined,\n>(\n  options?: {\n    method?: TMethod\n    response?: TServerFnResponseType\n    type?: ServerFnType\n  },\n  __opts?: ServerFnBaseOptions<\n    TMethod,\n    TServerFnResponseType,\n    TResponse,\n    TMiddlewares,\n    TValidator\n  >,\n): ServerFnBuilder<TMethod, TServerFnResponseType> {\n  const resolvedOptions = (__opts || options || {}) as ServerFnBaseOptions<\n    TMethod,\n    ServerFnResponseType,\n    TResponse,\n    TMiddlewares,\n    TValidator\n  >\n\n  if (typeof resolvedOptions.method === 'undefined') {\n    resolvedOptions.method = 'GET' as TMethod\n  }\n\n  return {\n    options: resolvedOptions as any,\n    middleware: (middleware) => {\n      return createServerFn<\n        TMethod,\n        ServerFnResponseType,\n        TResponse,\n        TMiddlewares,\n        TValidator\n      >(undefined, Object.assign(resolvedOptions, { middleware })) as any\n    },\n    validator: (validator) => {\n      return createServerFn<\n        TMethod,\n        ServerFnResponseType,\n        TResponse,\n        TMiddlewares,\n        TValidator\n      >(undefined, Object.assign(resolvedOptions, { validator })) as any\n    },\n    type: (type) => {\n      return createServerFn<\n        TMethod,\n        ServerFnResponseType,\n        TResponse,\n        TMiddlewares,\n        TValidator\n      >(undefined, Object.assign(resolvedOptions, { type })) as any\n    },\n    handler: (...args) => {\n      // This function signature changes due to AST transformations\n      // in the babel plugin. We need to cast it to the correct\n      // function signature post-transformation\n      const [extractedFn, serverFn] = args as unknown as [\n        CompiledFetcherFn<TResponse, TServerFnResponseType>,\n        ServerFn<\n          TMethod,\n          TServerFnResponseType,\n          TMiddlewares,\n          TValidator,\n          TResponse\n        >,\n      ]\n\n      // Keep the original function around so we can use it\n      // in the server environment\n      Object.assign(resolvedOptions, {\n        ...extractedFn,\n        extractedFn,\n        serverFn,\n      })\n\n      const resolvedMiddleware = [\n        ...(resolvedOptions.middleware || []),\n        serverFnBaseToMiddleware(resolvedOptions),\n      ]\n\n      // We want to make sure the new function has the same\n      // properties as the original function\n\n      return Object.assign(\n        async (opts?: CompiledFetcherFnOptions) => {\n          // Start by executing the client-side middleware chain\n          return executeMiddleware(resolvedMiddleware, 'client', {\n            ...extractedFn,\n            ...resolvedOptions,\n            data: opts?.data as any,\n            headers: opts?.headers,\n            signal: opts?.signal,\n            context: {},\n          }).then((d) => {\n            if (resolvedOptions.response === 'full') {\n              return d\n            }\n            if (d.error) throw d.error\n            return d.result\n          })\n        },\n        {\n          // This copies over the URL, function ID\n          ...extractedFn,\n          // The extracted function on the server-side calls\n          // this function\n          __executeServer: async (opts_: any, signal: AbortSignal) => {\n            const opts =\n              opts_ instanceof FormData ? extractFormDataContext(opts_) : opts_\n\n            opts.type =\n              typeof resolvedOptions.type === 'function'\n                ? resolvedOptions.type(opts)\n                : resolvedOptions.type\n\n            const ctx = {\n              ...extractedFn,\n              ...opts,\n              signal,\n            }\n\n            const run = () =>\n              executeMiddleware(resolvedMiddleware, 'server', ctx).then(\n                (d) => ({\n                  // Only send the result and sendContext back to the client\n                  result: d.result,\n                  error: d.error,\n                  context: d.sendContext,\n                }),\n              )\n\n            if (ctx.type === 'static') {\n              let response: StaticCachedResult | undefined\n\n              // If we can get the cached item, try to get it\n              if (serverFnStaticCache?.getItem) {\n                // If this throws, it's okay to let it bubble up\n                response = await serverFnStaticCache.getItem(ctx)\n              }\n\n              if (!response) {\n                // If there's no cached item, execute the server function\n                response = await run()\n                  .then((d) => {\n                    return {\n                      ctx: d,\n                      error: null,\n                    }\n                  })\n                  .catch((e) => {\n                    return {\n                      ctx: undefined,\n                      error: e,\n                    }\n                  })\n\n                if (serverFnStaticCache?.setItem) {\n                  await serverFnStaticCache.setItem(ctx, response)\n                }\n              }\n\n              invariant(\n                response,\n                'No response from both server and static cache!',\n              )\n\n              if (response.error) {\n                throw response.error\n              }\n\n              return response.ctx\n            }\n\n            return run()\n          },\n        },\n      ) as any\n    },\n  }\n}\n\nexport async function executeMiddleware(\n  middlewares: Array<AnyFunctionMiddleware>,\n  env: 'client' | 'server',\n  opts: ServerFnMiddlewareOptions,\n): Promise<ServerFnMiddlewareResult> {\n  const flattenedMiddlewares = flattenMiddlewares([\n    ...globalMiddleware,\n    ...middlewares,\n  ])\n\n  const next: NextFn = async (ctx) => {\n    // Get the next middleware\n    const nextMiddleware = flattenedMiddlewares.shift()\n\n    // If there are no more middlewares, return the context\n    if (!nextMiddleware) {\n      return ctx\n    }\n\n    if (\n      nextMiddleware.options.validator &&\n      (env === 'client' ? nextMiddleware.options.validateClient : true)\n    ) {\n      // Execute the middleware's input function\n      ctx.data = await execValidator(nextMiddleware.options.validator, ctx.data)\n    }\n\n    const middlewareFn = (\n      env === 'client'\n        ? nextMiddleware.options.client\n        : nextMiddleware.options.server\n    ) as MiddlewareFn | undefined\n\n    if (middlewareFn) {\n      // Execute the middleware\n      return applyMiddleware(middlewareFn, ctx, async (newCtx) => {\n        return next(newCtx).catch((error: any) => {\n          if (isRedirect(error) || isNotFound(error)) {\n            return {\n              ...newCtx,\n              error,\n            }\n          }\n\n          throw error\n        })\n      })\n    }\n\n    return next(ctx)\n  }\n\n  // Start the middleware chain\n  return next({\n    ...opts,\n    headers: opts.headers || {},\n    sendContext: opts.sendContext || {},\n    context: opts.context || {},\n  })\n}\n\nexport type CompiledFetcherFnOptions = {\n  method: Method\n  data: unknown\n  response?: ServerFnResponseType\n  headers?: HeadersInit\n  signal?: AbortSignal\n  context?: any\n}\n\nexport type Fetcher<\n  TMiddlewares,\n  TValidator,\n  TResponse,\n  TServerFnResponseType extends ServerFnResponseType,\n> =\n  undefined extends IntersectAllValidatorInputs<TMiddlewares, TValidator>\n    ? OptionalFetcher<\n        TMiddlewares,\n        TValidator,\n        TResponse,\n        TServerFnResponseType\n      >\n    : RequiredFetcher<\n        TMiddlewares,\n        TValidator,\n        TResponse,\n        TServerFnResponseType\n      >\n\nexport interface FetcherBase {\n  url: string\n  __executeServer: (opts: {\n    method: Method\n    response?: ServerFnResponseType\n    data: unknown\n    headers?: HeadersInit\n    context?: any\n    signal: AbortSignal\n  }) => Promise<unknown>\n}\n\nexport type FetchResult<\n  TMiddlewares,\n  TResponse,\n  TServerFnResponseType extends ServerFnResponseType,\n> = TServerFnResponseType extends 'raw'\n  ? Promise<Response>\n  : TServerFnResponseType extends 'full'\n    ? Promise<FullFetcherData<TMiddlewares, TResponse>>\n    : Promise<FetcherData<TResponse>>\n\nexport interface OptionalFetcher<\n  TMiddlewares,\n  TValidator,\n  TResponse,\n  TServerFnResponseType extends ServerFnResponseType,\n> extends FetcherBase {\n  (\n    options?: OptionalFetcherDataOptions<TMiddlewares, TValidator>,\n  ): FetchResult<TMiddlewares, TResponse, TServerFnResponseType>\n}\n\nexport interface RequiredFetcher<\n  TMiddlewares,\n  TValidator,\n  TResponse,\n  TServerFnResponseType extends ServerFnResponseType,\n> extends FetcherBase {\n  (\n    opts: RequiredFetcherDataOptions<TMiddlewares, TValidator>,\n  ): FetchResult<TMiddlewares, TResponse, TServerFnResponseType>\n}\n\nexport type FetcherBaseOptions = {\n  headers?: HeadersInit\n  type?: ServerFnType\n  signal?: AbortSignal\n}\n\nexport type ServerFnType = 'static' | 'dynamic'\n\nexport interface OptionalFetcherDataOptions<TMiddlewares, TValidator>\n  extends FetcherBaseOptions {\n  data?: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>\n}\n\nexport interface RequiredFetcherDataOptions<TMiddlewares, TValidator>\n  extends FetcherBaseOptions {\n  data: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>\n}\n\nexport interface FullFetcherData<TMiddlewares, TResponse> {\n  error: unknown\n  result: FetcherData<TResponse>\n  context: AssignAllClientSendContext<TMiddlewares>\n}\n\nexport type FetcherData<TResponse> =\n  TResponse extends JsonResponse<any>\n    ? SerializerParse<ReturnType<TResponse['json']>>\n    : SerializerParse<TResponse>\n\nexport type RscStream<T> = {\n  __cacheState: T\n}\n\nexport type Method = 'GET' | 'POST'\nexport type ServerFnResponseType = 'data' | 'full' | 'raw'\n\n// see https://h3.unjs.io/guide/event-handler#responses-types\nexport type RawResponse = Response | ReadableStream | Readable | null | string\n\nexport type ServerFnReturnType<\n  TServerFnResponseType extends ServerFnResponseType,\n  TResponse,\n> = TServerFnResponseType extends 'raw'\n  ? RawResponse | Promise<RawResponse>\n  : Promise<SerializerStringify<TResponse>> | SerializerStringify<TResponse>\n\nexport type ServerFn<\n  TMethod,\n  TServerFnResponseType extends ServerFnResponseType,\n  TMiddlewares,\n  TValidator,\n  TResponse,\n> = (\n  ctx: ServerFnCtx<TMethod, TServerFnResponseType, TMiddlewares, TValidator>,\n) => ServerFnReturnType<TServerFnResponseType, TResponse>\n\nexport interface ServerFnCtx<\n  TMethod,\n  TServerFnResponseType extends ServerFnResponseType,\n  TMiddlewares,\n  TValidator,\n> {\n  method: TMethod\n  response: TServerFnResponseType\n  data: Expand<IntersectAllValidatorOutputs<TMiddlewares, TValidator>>\n  context: Expand<AssignAllServerContext<TMiddlewares>>\n  signal: AbortSignal\n}\n\nexport type CompiledFetcherFn<\n  TResponse,\n  TServerFnResponseType extends ServerFnResponseType,\n> = {\n  (\n    opts: CompiledFetcherFnOptions &\n      ServerFnBaseOptions<Method, TServerFnResponseType>,\n  ): Promise<TResponse>\n  url: string\n}\n\nexport type ServerFnBaseOptions<\n  TMethod extends Method = 'GET',\n  TServerFnResponseType extends ServerFnResponseType = 'data',\n  TResponse = unknown,\n  TMiddlewares = unknown,\n  TInput = unknown,\n> = {\n  method: TMethod\n  response?: TServerFnResponseType\n  validateClient?: boolean\n  middleware?: Constrain<TMiddlewares, ReadonlyArray<AnyFunctionMiddleware>>\n  validator?: ConstrainValidator<TInput>\n  extractedFn?: CompiledFetcherFn<TResponse, TServerFnResponseType>\n  serverFn?: ServerFn<\n    TMethod,\n    TServerFnResponseType,\n    TMiddlewares,\n    TInput,\n    TResponse\n  >\n  functionId: string\n  type: ServerFnTypeOrTypeFn<\n    TMethod,\n    TServerFnResponseType,\n    TMiddlewares,\n    AnyValidator\n  >\n}\n\nexport type ValidatorInputStringify<TValidator> = SerializerStringifyBy<\n  ResolveValidatorInput<TValidator>,\n  Date | undefined | FormData\n>\n\nexport type ValidatorSerializerStringify<TValidator> =\n  ValidatorInputStringify<TValidator> extends infer TInput\n    ? Validator<TInput, any>\n    : never\n\nexport type ConstrainValidator<TValidator> =\n  | (unknown extends TValidator\n      ? TValidator\n      : ResolveValidatorInput<TValidator> extends ValidatorInputStringify<TValidator>\n        ? TValidator\n        : never)\n  | ValidatorSerializerStringify<TValidator>\n\nexport interface ServerFnMiddleware<\n  TMethod extends Method,\n  TServerFnResponseType extends ServerFnResponseType,\n  TValidator,\n> {\n  middleware: <const TNewMiddlewares = undefined>(\n    middlewares: Constrain<\n      TNewMiddlewares,\n      ReadonlyArray<AnyFunctionMiddleware>\n    >,\n  ) => ServerFnAfterMiddleware<\n    TMethod,\n    TServerFnResponseType,\n    TNewMiddlewares,\n    TValidator\n  >\n}\n\nexport interface ServerFnAfterMiddleware<\n  TMethod extends Method,\n  TServerFnResponseType extends ServerFnResponseType,\n  TMiddlewares,\n  TValidator,\n> extends ServerFnValidator<TMethod, TServerFnResponseType, TMiddlewares>,\n    ServerFnTyper<TMethod, TServerFnResponseType, TMiddlewares, TValidator>,\n    ServerFnHandler<TMethod, TServerFnResponseType, TMiddlewares, TValidator> {}\n\nexport type ValidatorFn<\n  TMethod extends Method,\n  TServerFnResponseType extends ServerFnResponseType,\n  TMiddlewares,\n> = <TValidator>(\n  validator: ConstrainValidator<TValidator>,\n) => ServerFnAfterValidator<\n  TMethod,\n  TServerFnResponseType,\n  TMiddlewares,\n  TValidator\n>\n\nexport interface ServerFnValidator<\n  TMethod extends Method,\n  TServerFnResponseType extends ServerFnResponseType,\n  TMiddlewares,\n> {\n  validator: ValidatorFn<TMethod, TServerFnResponseType, TMiddlewares>\n}\n\nexport interface ServerFnAfterValidator<\n  TMethod extends Method,\n  TServerFnResponseType extends ServerFnResponseType,\n  TMiddlewares,\n  TValidator,\n> extends ServerFnMiddleware<TMethod, TServerFnResponseType, TValidator>,\n    ServerFnTyper<TMethod, TServerFnResponseType, TMiddlewares, TValidator>,\n    ServerFnHandler<TMethod, TServerFnResponseType, TMiddlewares, TValidator> {}\n\n// Typer\nexport interface ServerFnTyper<\n  TMethod extends Method,\n  TServerFnResponseType extends ServerFnResponseType,\n  TMiddlewares,\n  TValidator,\n> {\n  type: (\n    typer: ServerFnTypeOrTypeFn<\n      TMethod,\n      TServerFnResponseType,\n      TMiddlewares,\n      TValidator\n    >,\n  ) => ServerFnAfterTyper<\n    TMethod,\n    TServerFnResponseType,\n    TMiddlewares,\n    TValidator\n  >\n}\n\nexport type ServerFnTypeOrTypeFn<\n  TMethod extends Method,\n  TServerFnResponseType extends ServerFnResponseType,\n  TMiddlewares,\n  TValidator,\n> =\n  | ServerFnType\n  | ((\n      ctx: ServerFnCtx<\n        TMethod,\n        TServerFnResponseType,\n        TMiddlewares,\n        TValidator\n      >,\n    ) => ServerFnType)\n\nexport interface ServerFnAfterTyper<\n  TMethod extends Method,\n  TServerFnResponseType extends ServerFnResponseType,\n  TMiddlewares,\n  TValidator,\n> extends ServerFnHandler<\n    TMethod,\n    TServerFnResponseType,\n    TMiddlewares,\n    TValidator\n  > {}\n\n// Handler\nexport interface ServerFnHandler<\n  TMethod extends Method,\n  TServerFnResponseType extends ServerFnResponseType,\n  TMiddlewares,\n  TValidator,\n> {\n  handler: <TNewResponse>(\n    fn?: ServerFn<\n      TMethod,\n      TServerFnResponseType,\n      TMiddlewares,\n      TValidator,\n      TNewResponse\n    >,\n  ) => Fetcher<TMiddlewares, TValidator, TNewResponse, TServerFnResponseType>\n}\n\nexport interface ServerFnBuilder<\n  TMethod extends Method = 'GET',\n  TServerFnResponseType extends ServerFnResponseType = 'data',\n> extends ServerFnMiddleware<TMethod, TServerFnResponseType, undefined>,\n    ServerFnValidator<TMethod, TServerFnResponseType, undefined>,\n    ServerFnTyper<TMethod, TServerFnResponseType, undefined, undefined>,\n    ServerFnHandler<TMethod, TServerFnResponseType, undefined, undefined> {\n  options: ServerFnBaseOptions<\n    TMethod,\n    TServerFnResponseType,\n    unknown,\n    undefined,\n    undefined\n  >\n}\n\nexport type StaticCachedResult = {\n  ctx?: {\n    result: any\n    context: any\n  }\n  error?: any\n}\n\nexport type ServerFnStaticCache = {\n  getItem: (\n    ctx: ServerFnMiddlewareResult,\n  ) => StaticCachedResult | Promise<StaticCachedResult | undefined>\n  setItem: (\n    ctx: ServerFnMiddlewareResult,\n    response: StaticCachedResult,\n  ) => Promise<void>\n  fetchItem: (\n    ctx: ServerFnMiddlewareResult,\n  ) => StaticCachedResult | Promise<StaticCachedResult | undefined>\n}\n\nexport let serverFnStaticCache: ServerFnStaticCache | undefined\n\nexport function setServerFnStaticCache(\n  cache?: ServerFnStaticCache | (() => ServerFnStaticCache | undefined),\n) {\n  const previousCache = serverFnStaticCache\n  serverFnStaticCache = typeof cache === 'function' ? cache() : cache\n\n  return () => {\n    serverFnStaticCache = previousCache\n  }\n}\n\nexport function createServerFnStaticCache(\n  serverFnStaticCache: ServerFnStaticCache,\n) {\n  return serverFnStaticCache\n}\n\n/**\n * This is a simple hash function for generating a hash from a string to make the filenames shorter.\n *\n * It is not cryptographically secure (as its using SHA-1) and should not be used for any security purposes.\n *\n * It is only used to generate a hash for the static cache filenames.\n *\n * @param message - The input string to hash.\n * @returns A promise that resolves to the SHA-1 hash of the input string in hexadecimal format.\n *\n * @example\n * ```typescript\n * const hash = await sha1Hash(\"hello\");\n * console.log(hash); // Outputs the SHA-1 hash of \"hello\" -> \"aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d\"\n * ```\n */\nasync function sha1Hash(message: string): Promise<string> {\n  // Encode the string as UTF-8\n  const msgBuffer = new TextEncoder().encode(message)\n\n  // Hash the message\n  const hashBuffer = await crypto.subtle.digest('SHA-1', msgBuffer)\n\n  // Convert the ArrayBuffer to a string\n  const hashArray = Array.from(new Uint8Array(hashBuffer))\n  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('')\n  return hashHex\n}\n\nsetServerFnStaticCache(() => {\n  const getStaticCacheUrl = async (\n    options: ServerFnMiddlewareResult,\n    hash: string,\n  ) => {\n    const filename = await sha1Hash(`${options.functionId}__${hash}`)\n    return `/__tsr/staticServerFnCache/${filename}.json`\n  }\n\n  const jsonToFilenameSafeString = (json: any) => {\n    // Custom replacer to sort keys\n    const sortedKeysReplacer = (key: string, value: any) =>\n      value && typeof value === 'object' && !Array.isArray(value)\n        ? Object.keys(value)\n            .sort()\n            .reduce((acc: any, curr: string) => {\n              acc[curr] = value[curr]\n              return acc\n            }, {})\n        : value\n\n    // Convert JSON to string with sorted keys\n    const jsonString = JSON.stringify(json ?? '', sortedKeysReplacer)\n\n    // Replace characters invalid in filenames\n    return jsonString\n      .replace(/[/\\\\?%*:|\"<>]/g, '-') // Replace invalid characters with a dash\n      .replace(/\\s+/g, '_') // Optionally replace whitespace with underscores\n  }\n\n  const staticClientCache =\n    typeof document !== 'undefined' ? new Map<string, any>() : null\n\n  return createServerFnStaticCache({\n    getItem: async (ctx) => {\n      if (typeof document === 'undefined') {\n        const hash = jsonToFilenameSafeString(ctx.data)\n        const url = await getStaticCacheUrl(ctx, hash)\n        const publicUrl = process.env.TSS_OUTPUT_PUBLIC_DIR!\n\n        // Use fs instead of fetch to read from filesystem\n        const { promises: fs } = await import('node:fs')\n        const path = await import('node:path')\n        const filePath = path.join(publicUrl, url)\n\n        const [cachedResult, readError] = await fs\n          .readFile(filePath, 'utf-8')\n          .then((c) => [\n            startSerializer.parse(c) as {\n              ctx: unknown\n              error: any\n            },\n            null,\n          ])\n          .catch((e) => [null, e])\n\n        if (readError && readError.code !== 'ENOENT') {\n          throw readError\n        }\n\n        return cachedResult as StaticCachedResult\n      }\n\n      return undefined\n    },\n    setItem: async (ctx, response) => {\n      const { promises: fs } = await import('node:fs')\n      const path = await import('node:path')\n\n      const hash = jsonToFilenameSafeString(ctx.data)\n      const url = await getStaticCacheUrl(ctx, hash)\n      const publicUrl = process.env.TSS_OUTPUT_PUBLIC_DIR!\n      const filePath = path.join(publicUrl, url)\n\n      // Ensure the directory exists\n      await fs.mkdir(path.dirname(filePath), { recursive: true })\n\n      // Store the result with fs\n      await fs.writeFile(filePath, startSerializer.stringify(response))\n    },\n    fetchItem: async (ctx) => {\n      const hash = jsonToFilenameSafeString(ctx.data)\n      const url = await getStaticCacheUrl(ctx, hash)\n\n      let result: any = staticClientCache?.get(url)\n\n      if (!result) {\n        result = await fetch(url, {\n          method: 'GET',\n        })\n          .then((r) => r.text())\n          .then((d) => startSerializer.parse(d))\n\n        staticClientCache?.set(url, result)\n      }\n\n      return result\n    },\n  })\n})\n\nexport function extractFormDataContext(formData: FormData) {\n  const serializedContext = formData.get('__TSR_CONTEXT')\n  formData.delete('__TSR_CONTEXT')\n\n  if (typeof serializedContext !== 'string') {\n    return {\n      context: {},\n      data: formData,\n    }\n  }\n\n  try {\n    const context = startSerializer.parse(serializedContext)\n    return {\n      context,\n      data: formData,\n    }\n  } catch {\n    return {\n      data: formData,\n    }\n  }\n}\n\nexport function flattenMiddlewares(\n  middlewares: Array<AnyFunctionMiddleware>,\n): Array<AnyFunctionMiddleware> {\n  const seen = new Set<AnyFunctionMiddleware>()\n  const flattened: Array<AnyFunctionMiddleware> = []\n\n  const recurse = (middleware: Array<AnyFunctionMiddleware>) => {\n    middleware.forEach((m) => {\n      if (m.options.middleware) {\n        recurse(m.options.middleware)\n      }\n\n      if (!seen.has(m)) {\n        seen.add(m)\n        flattened.push(m)\n      }\n    })\n  }\n\n  recurse(middlewares)\n\n  return flattened\n}\n\nexport type ServerFnMiddlewareOptions = {\n  method: Method\n  response?: ServerFnResponseType\n  data: any\n  headers?: HeadersInit\n  signal?: AbortSignal\n  sendContext?: any\n  context?: any\n  type: ServerFnTypeOrTypeFn<any, any, any, any>\n  functionId: string\n}\n\nexport type ServerFnMiddlewareResult = ServerFnMiddlewareOptions & {\n  result?: unknown\n  error?: unknown\n  type: ServerFnTypeOrTypeFn<any, any, any, any>\n}\n\nexport type NextFn = (\n  ctx: ServerFnMiddlewareResult,\n) => Promise<ServerFnMiddlewareResult>\n\nexport type MiddlewareFn = (\n  ctx: ServerFnMiddlewareOptions & {\n    next: NextFn\n  },\n) => Promise<ServerFnMiddlewareResult>\n\nexport const applyMiddleware = async (\n  middlewareFn: MiddlewareFn,\n  ctx: ServerFnMiddlewareOptions,\n  nextFn: NextFn,\n) => {\n  return middlewareFn({\n    ...ctx,\n    next: (async (\n      userCtx: ServerFnMiddlewareResult | undefined = {} as any,\n    ) => {\n      // Return the next middleware\n      return nextFn({\n        ...ctx,\n        ...userCtx,\n        context: {\n          ...ctx.context,\n          ...userCtx.context,\n        },\n        sendContext: {\n          ...ctx.sendContext,\n          ...(userCtx.sendContext ?? {}),\n        },\n        headers: mergeHeaders(ctx.headers, userCtx.headers),\n        result:\n          userCtx.result !== undefined\n            ? userCtx.result\n            : ctx.response === 'raw'\n              ? userCtx\n              : (ctx as any).result,\n        error: userCtx.error ?? (ctx as any).error,\n      })\n    }) as any,\n  } as any)\n}\n\nexport function execValidator(\n  validator: AnyValidator,\n  input: unknown,\n): unknown {\n  if (validator == null) return {}\n\n  if ('~standard' in validator) {\n    const result = validator['~standard'].validate(input)\n\n    if (result instanceof Promise)\n      throw new Error('Async validation not supported')\n\n    if (result.issues)\n      throw new Error(JSON.stringify(result.issues, undefined, 2))\n\n    return result.value\n  }\n\n  if ('parse' in validator) {\n    return validator.parse(input)\n  }\n\n  if (typeof validator === 'function') {\n    return validator(input)\n  }\n\n  throw new Error('Invalid validator type!')\n}\n\nexport function serverFnBaseToMiddleware(\n  options: ServerFnBaseOptions<any, any, any, any, any>,\n): AnyFunctionMiddleware {\n  return {\n    _types: undefined!,\n    options: {\n      validator: options.validator,\n      validateClient: options.validateClient,\n      client: async ({ next, sendContext, ...ctx }) => {\n        const payload = {\n          ...ctx,\n          // switch the sendContext over to context\n          context: sendContext,\n          type: typeof ctx.type === 'function' ? ctx.type(ctx) : ctx.type,\n        } as any\n\n        if (\n          ctx.type === 'static' &&\n          process.env.NODE_ENV === 'production' &&\n          typeof document !== 'undefined'\n        ) {\n          invariant(\n            serverFnStaticCache,\n            'serverFnStaticCache.fetchItem is not available!',\n          )\n\n          const result = await serverFnStaticCache.fetchItem(payload)\n\n          if (result) {\n            if (result.error) {\n              throw result.error\n            }\n\n            return next(result.ctx)\n          }\n\n          warning(\n            result,\n            `No static cache item found for ${payload.functionId}__${JSON.stringify(payload.data)}, falling back to server function...`,\n          )\n        }\n\n        // Execute the extracted function\n        // but not before serializing the context\n        const res = await options.extractedFn?.(payload)\n\n        return next(res) as unknown as FunctionMiddlewareClientFnResult<\n          any,\n          any,\n          any\n        >\n      },\n      server: async ({ next, ...ctx }) => {\n        // Execute the server function\n        const result = await options.serverFn?.(ctx as TODO)\n\n        return next({\n          ...ctx,\n          result,\n        } as any) as unknown as FunctionMiddlewareServerFnResult<\n          any,\n          any,\n          any,\n          any\n        >\n      },\n    },\n  }\n}\n", "import type {\n  ConstrainValidator,\n  Method,\n  ServerFnResponseType,\n  ServerFnTypeOrTypeFn,\n} from './createServerFn'\nimport type {\n  Assign,\n  Constrain,\n  Expand,\n  IntersectAssign,\n  ResolveValidatorInput,\n  ResolveValidatorOutput,\n} from '@tanstack/router-core'\nimport type { SerializerStringify } from './serializer'\n\nexport function createMiddleware<TType extends MiddlewareType>(\n  options: {\n    type: TType\n    validateClient?: boolean\n  },\n  __opts?: FunctionMiddlewareOptions<\n    unknown,\n    undefined,\n    undefined,\n    undefined,\n    ServerFnResponseType\n  >,\n): CreateMiddlewareResult<TType> {\n  // const resolvedOptions = (__opts || options) as MiddlewareOptions<\n  const resolvedOptions = {\n    type: 'function',\n    ...(__opts ||\n      (options as FunctionMiddlewareOptions<\n        unknown,\n        undefined,\n        undefined,\n        undefined,\n        ServerFnResponseType\n      >)),\n  }\n\n  return {\n    options: resolvedOptions,\n    middleware: (middleware: any) => {\n      return createMiddleware(\n        {} as any,\n        Object.assign(resolvedOptions, { middleware }),\n      ) as any\n    },\n    validator: (validator: any) => {\n      return createMiddleware(\n        {} as any,\n        Object.assign(resolvedOptions, { validator }),\n      ) as any\n    },\n    client: (client: any) => {\n      return createMiddleware(\n        {} as any,\n        Object.assign(resolvedOptions, { client }),\n      ) as any\n    },\n    server: (server: any) => {\n      return createMiddleware(\n        {} as any,\n        Object.assign(resolvedOptions, { server }),\n      ) as any\n    },\n  } as unknown as CreateMiddlewareResult<TType>\n}\n\nexport type MiddlewareType = 'request' | 'function'\n\nexport type CreateMiddlewareResult<TType extends MiddlewareType> =\n  'function' extends TType\n    ? FunctionMiddleware<ServerFnResponseType>\n    : RequestMiddleware\n\nexport interface FunctionMiddleware<\n  TServerFnResponseType extends ServerFnResponseType,\n> extends FunctionMiddlewareAfterMiddleware<unknown, TServerFnResponseType> {\n  middleware: <const TNewMiddlewares = undefined>(\n    middlewares: Constrain<\n      TNewMiddlewares,\n      ReadonlyArray<AnyFunctionMiddleware>\n    >,\n  ) => FunctionMiddlewareAfterMiddleware<TNewMiddlewares, TServerFnResponseType>\n}\n\nexport interface FunctionMiddlewareAfterMiddleware<\n  TMiddlewares,\n  TServerFnResponseType extends ServerFnResponseType,\n> extends FunctionMiddlewareWithTypes<\n      TMiddlewares,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      TServerFnResponseType\n    >,\n    FunctionMiddlewareServer<\n      TMiddlewares,\n      undefined,\n      undefined,\n      undefined,\n      TServerFnResponseType\n    >,\n    FunctionMiddlewareClient<TMiddlewares, undefined, TServerFnResponseType>,\n    FunctionMiddlewareValidator<TMiddlewares, TServerFnResponseType> {}\n\nexport interface FunctionMiddlewareWithTypes<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TServerSendContext,\n  TClientContext,\n  TClientSendContext,\n  TServerFnResponseType extends ServerFnResponseType,\n> {\n  _types: FunctionMiddlewareTypes<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TServerSendContext,\n    TClientContext,\n    TClientSendContext\n  >\n  options: FunctionMiddlewareOptions<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext,\n    TServerFnResponseType\n  >\n}\n\nexport interface FunctionMiddlewareTypes<\n  in out TMiddlewares,\n  in out TValidator,\n  in out TServerContext,\n  in out TServerSendContext,\n  in out TClientContext,\n  in out TClientSendContext,\n> {\n  type: 'function'\n  middlewares: TMiddlewares\n  input: ResolveValidatorInput<TValidator>\n  allInput: IntersectAllValidatorInputs<TMiddlewares, TValidator>\n  output: ResolveValidatorOutput<TValidator>\n  allOutput: IntersectAllValidatorOutputs<TMiddlewares, TValidator>\n  clientContext: TClientContext\n  allClientContextBeforeNext: AssignAllClientContextBeforeNext<\n    TMiddlewares,\n    TClientContext\n  >\n  allClientContextAfterNext: AssignAllClientContextAfterNext<\n    TMiddlewares,\n    TClientContext,\n    TClientSendContext\n  >\n  serverContext: TServerContext\n  serverSendContext: TServerSendContext\n  allServerSendContext: AssignAllServerSendContext<\n    TMiddlewares,\n    TServerSendContext\n  >\n  allServerContext: AssignAllServerContext<\n    TMiddlewares,\n    TServerSendContext,\n    TServerContext\n  >\n  clientSendContext: TClientSendContext\n  allClientSendContext: AssignAllClientSendContext<\n    TMiddlewares,\n    TClientSendContext\n  >\n  validator: TValidator\n}\n\n/**\n * Recursively resolve the input type produced by a sequence of middleware\n */\nexport type IntersectAllValidatorInputs<TMiddlewares, TValidator> =\n  unknown extends TValidator\n    ? TValidator\n    : TValidator extends undefined\n      ? IntersectAllMiddleware<TMiddlewares, 'allInput'>\n      : IntersectAssign<\n          IntersectAllMiddleware<TMiddlewares, 'allInput'>,\n          ResolveValidatorInput<TValidator>\n        >\n\nexport type IntersectAllMiddleware<\n  TMiddlewares,\n  TType extends\n    | keyof AnyFunctionMiddleware['_types']\n    | keyof AnyRequestMiddleware['_types'],\n  TAcc = undefined,\n> = TMiddlewares extends readonly [infer TMiddleware, ...infer TRest]\n  ? TMiddleware extends AnyFunctionMiddleware | AnyRequestMiddleware\n    ? IntersectAllMiddleware<\n        TRest,\n        TType,\n        IntersectAssign<\n          TAcc,\n          TMiddleware['_types'][TType & keyof TMiddleware['_types']]\n        >\n      >\n    : TAcc\n  : TAcc\n\nexport type AnyFunctionMiddleware = FunctionMiddlewareWithTypes<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * Recursively merge the output type produced by a sequence of middleware\n */\nexport type IntersectAllValidatorOutputs<TMiddlewares, TValidator> =\n  unknown extends TValidator\n    ? TValidator\n    : TValidator extends undefined\n      ? IntersectAllMiddleware<TMiddlewares, 'allOutput'>\n      : IntersectAssign<\n          IntersectAllMiddleware<TMiddlewares, 'allOutput'>,\n          ResolveValidatorOutput<TValidator>\n        >\n\n/**\n * Recursively resolve the client context type produced by a sequence of middleware\n */\nexport type AssignAllClientContextBeforeNext<\n  TMiddlewares,\n  TClientContext = undefined,\n> = unknown extends TClientContext\n  ? TClientContext\n  : Assign<\n      AssignAllMiddleware<TMiddlewares, 'allClientContextBeforeNext'>,\n      TClientContext\n    >\n\nexport type AssignAllMiddleware<\n  TMiddlewares,\n  TType extends\n    | keyof AnyFunctionMiddleware['_types']\n    | keyof AnyRequestMiddleware['_types'],\n  TAcc = undefined,\n> = TMiddlewares extends readonly [infer TMiddleware, ...infer TRest]\n  ? TMiddleware extends AnyFunctionMiddleware | AnyRequestMiddleware\n    ? AssignAllMiddleware<\n        TRest,\n        TType,\n        Assign<TAcc, TMiddleware['_types'][TType & keyof TMiddleware['_types']]>\n      >\n    : TAcc\n  : TAcc\n\nexport type AssignAllClientContextAfterNext<\n  TMiddlewares,\n  TClientContext = undefined,\n  TSendContext = undefined,\n> = unknown extends TClientContext\n  ? Assign<TClientContext, TSendContext>\n  : Assign<\n      AssignAllMiddleware<TMiddlewares, 'allClientContextAfterNext'>,\n      Assign<TClientContext, TSendContext>\n    >\n\nexport type AssignAllServerSendContext<\n  TMiddlewares,\n  TSendContext = undefined,\n> = unknown extends TSendContext\n  ? TSendContext\n  : Assign<\n      AssignAllMiddleware<TMiddlewares, 'allServerSendContext'>,\n      TSendContext\n    >\n\n/**\n * Recursively resolve the server context type produced by a sequence of middleware\n */\nexport type AssignAllServerContext<\n  TMiddlewares,\n  TSendContext = undefined,\n  TServerContext = undefined,\n> = unknown extends TSendContext\n  ? Assign<TSendContext, TServerContext>\n  : Assign<\n      AssignAllMiddleware<TMiddlewares, 'allServerContext'>,\n      Assign<TSendContext, TServerContext>\n    >\n\nexport type AssignAllClientSendContext<\n  TMiddlewares,\n  TSendContext = undefined,\n> = unknown extends TSendContext\n  ? TSendContext\n  : Assign<\n      AssignAllMiddleware<TMiddlewares, 'allClientSendContext'>,\n      TSendContext\n    >\n\nexport interface FunctionMiddlewareOptions<\n  in out TMiddlewares,\n  in out TValidator,\n  in out TServerContext,\n  in out TClientContext,\n  in out TServerFnResponseType extends ServerFnResponseType,\n> {\n  validateClient?: boolean\n  middleware?: TMiddlewares\n  validator?: ConstrainValidator<TValidator>\n  client?: FunctionMiddlewareClientFn<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext,\n    TServerFnResponseType\n  >\n  server?: FunctionMiddlewareServerFn<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    unknown,\n    unknown,\n    TServerFnResponseType\n  >\n}\n\nexport type FunctionMiddlewareClientNextFn<TMiddlewares> = <\n  TSendContext = undefined,\n  TNewClientContext = undefined,\n>(ctx?: {\n  context?: TNewClientContext\n  sendContext?: SerializerStringify<TSendContext>\n  headers?: HeadersInit\n}) => Promise<\n  FunctionClientResultWithContext<TMiddlewares, TSendContext, TNewClientContext>\n>\n\nexport interface FunctionMiddlewareServer<\n  TMiddlewares,\n  TValidator,\n  TServerSendContext,\n  TClientContext,\n  TServerFnResponseType extends ServerFnResponseType,\n> {\n  server: <TNewServerContext = undefined, TSendContext = undefined>(\n    server: FunctionMiddlewareServerFn<\n      TMiddlewares,\n      TValidator,\n      TServerSendContext,\n      TNewServerContext,\n      TSendContext,\n      TServerFnResponseType\n    >,\n  ) => FunctionMiddlewareAfterServer<\n    TMiddlewares,\n    TValidator,\n    TNewServerContext,\n    TServerSendContext,\n    TClientContext,\n    TSendContext,\n    ServerFnResponseType\n  >\n}\nexport type FunctionMiddlewareServerFn<\n  TMiddlewares,\n  TValidator,\n  TServerSendContext,\n  TNewServerContext,\n  TSendContext,\n  TServerFnResponseType extends ServerFnResponseType,\n> = (\n  options: FunctionMiddlewareServerFnOptions<\n    TMiddlewares,\n    TValidator,\n    TServerSendContext,\n    TServerFnResponseType\n  >,\n) => FunctionMiddlewareServerFnResult<\n  TMiddlewares,\n  TServerSendContext,\n  TNewServerContext,\n  TSendContext\n>\n\nexport interface RequestMiddlewareServerFnOptions<\n  in out TMiddlewares,\n  in out TServerSendContext,\n> {\n  request: Request\n  context: Expand<AssignAllServerContext<TMiddlewares, TServerSendContext>>\n  next: FunctionMiddlewareServerNextFn<TMiddlewares, TServerSendContext>\n  response: Response\n  method: Method\n  signal: AbortSignal\n}\n\nexport type FunctionMiddlewareServerNextFn<TMiddlewares, TServerSendContext> = <\n  TNewServerContext = undefined,\n  TSendContext = undefined,\n>(ctx?: {\n  context?: TNewServerContext\n  sendContext?: SerializerStringify<TSendContext>\n}) => Promise<\n  FunctionServerResultWithContext<\n    TMiddlewares,\n    TServerSendContext,\n    TNewServerContext,\n    TSendContext\n  >\n>\n\nexport type FunctionServerResultWithContext<\n  in out TMiddlewares,\n  in out TServerSendContext,\n  in out TServerContext,\n  in out TSendContext,\n> = {\n  'use functions must return the result of next()': true\n  _types: {\n    context: TServerContext\n    sendContext: TSendContext\n  }\n  context: Expand<\n    AssignAllServerContext<TMiddlewares, TServerSendContext, TServerContext>\n  >\n  sendContext: Expand<AssignAllClientSendContext<TMiddlewares, TSendContext>>\n}\n\nexport interface FunctionMiddlewareServerFnOptions<\n  in out TMiddlewares,\n  in out TValidator,\n  in out TServerSendContext,\n  in out TServerFnResponseType,\n> {\n  data: Expand<IntersectAllValidatorOutputs<TMiddlewares, TValidator>>\n  context: Expand<AssignAllServerContext<TMiddlewares, TServerSendContext>>\n  next: FunctionMiddlewareServerNextFn<TMiddlewares, TServerSendContext>\n  response: TServerFnResponseType\n  method: Method\n  filename: string\n  functionId: string\n  signal: AbortSignal\n}\n\nexport type FunctionMiddlewareServerFnResult<\n  TMiddlewares,\n  TServerSendContext,\n  TServerContext,\n  TSendContext,\n> =\n  | Promise<\n      FunctionServerResultWithContext<\n        TMiddlewares,\n        TServerSendContext,\n        TServerContext,\n        TSendContext\n      >\n    >\n  | FunctionServerResultWithContext<\n      TMiddlewares,\n      TServerSendContext,\n      TServerContext,\n      TSendContext\n    >\n\nexport interface FunctionMiddlewareAfterServer<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TServerSendContext,\n  TClientContext,\n  TClientSendContext,\n  TServerFnResponseType extends ServerFnResponseType,\n> extends FunctionMiddlewareWithTypes<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TServerSendContext,\n    TClientContext,\n    TClientSendContext,\n    TServerFnResponseType\n  > {}\n\nexport interface FunctionMiddlewareClient<\n  TMiddlewares,\n  TValidator,\n  TServerFnResponseType extends ServerFnResponseType,\n> {\n  client: <TSendServerContext = undefined, TNewClientContext = undefined>(\n    client: FunctionMiddlewareClientFn<\n      TMiddlewares,\n      TValidator,\n      TSendServerContext,\n      TNewClientContext,\n      TServerFnResponseType\n    >,\n  ) => FunctionMiddlewareAfterClient<\n    TMiddlewares,\n    TValidator,\n    TSendServerContext,\n    TNewClientContext,\n    ServerFnResponseType\n  >\n}\n\nexport type FunctionMiddlewareClientFn<\n  TMiddlewares,\n  TValidator,\n  TSendContext,\n  TClientContext,\n  TServerFnResponseType extends ServerFnResponseType,\n> = (\n  options: FunctionMiddlewareClientFnOptions<\n    TMiddlewares,\n    TValidator,\n    TServerFnResponseType\n  >,\n) => FunctionMiddlewareClientFnResult<\n  TMiddlewares,\n  TSendContext,\n  TClientContext\n>\n\nexport interface FunctionMiddlewareClientFnOptions<\n  in out TMiddlewares,\n  in out TValidator,\n  in out TServerFnResponseType extends ServerFnResponseType,\n> {\n  data: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>\n  context: Expand<AssignAllClientContextBeforeNext<TMiddlewares>>\n  sendContext: Expand<AssignAllServerSendContext<TMiddlewares>>\n  method: Method\n  response: TServerFnResponseType\n  signal: AbortSignal\n  next: FunctionMiddlewareClientNextFn<TMiddlewares>\n  filename: string\n  functionId: string\n  type: ServerFnTypeOrTypeFn<\n    Method,\n    TServerFnResponseType,\n    TMiddlewares,\n    TValidator\n  >\n}\n\nexport type FunctionMiddlewareClientFnResult<\n  TMiddlewares,\n  TSendContext,\n  TClientContext,\n> =\n  | Promise<\n      FunctionClientResultWithContext<\n        TMiddlewares,\n        TSendContext,\n        TClientContext\n      >\n    >\n  | FunctionClientResultWithContext<TMiddlewares, TSendContext, TClientContext>\n\nexport type FunctionClientResultWithContext<\n  in out TMiddlewares,\n  in out TSendContext,\n  in out TClientContext,\n> = {\n  'use functions must return the result of next()': true\n  context: Expand<AssignAllClientContextAfterNext<TMiddlewares, TClientContext>>\n  sendContext: Expand<AssignAllServerSendContext<TMiddlewares, TSendContext>>\n  headers: HeadersInit\n}\n\nexport interface FunctionMiddlewareAfterClient<\n  TMiddlewares,\n  TValidator,\n  TServerSendContext,\n  TClientContext,\n  TServerFnResponseType extends ServerFnResponseType,\n> extends FunctionMiddlewareWithTypes<\n      TMiddlewares,\n      TValidator,\n      undefined,\n      TServerSendContext,\n      TClientContext,\n      undefined,\n      TServerFnResponseType\n    >,\n    FunctionMiddlewareServer<\n      TMiddlewares,\n      TValidator,\n      TServerSendContext,\n      TClientContext,\n      TServerFnResponseType\n    > {}\n\nexport interface FunctionMiddlewareValidator<\n  TMiddlewares,\n  TServerFnResponseType extends ServerFnResponseType,\n> {\n  validator: <TNewValidator>(\n    input: ConstrainValidator<TNewValidator>,\n  ) => FunctionMiddlewareAfterValidator<\n    TMiddlewares,\n    TNewValidator,\n    TServerFnResponseType\n  >\n}\n\nexport interface FunctionMiddlewareAfterValidator<\n  TMiddlewares,\n  TValidator,\n  TServerFnResponseType extends ServerFnResponseType,\n> extends FunctionMiddlewareWithTypes<\n      TMiddlewares,\n      TValidator,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      ServerFnResponseType\n    >,\n    FunctionMiddlewareServer<\n      TMiddlewares,\n      TValidator,\n      undefined,\n      undefined,\n      TServerFnResponseType\n    >,\n    FunctionMiddlewareClient<TMiddlewares, TValidator, ServerFnResponseType> {}\n\nexport interface RequestMiddleware\n  extends RequestMiddlewareAfterMiddleware<undefined> {\n  middleware: <const TMiddlewares = undefined>(\n    middlewares: Constrain<TMiddlewares, ReadonlyArray<AnyRequestMiddleware>>,\n  ) => RequestMiddlewareAfterMiddleware<TMiddlewares>\n}\n\nexport type AnyRequestMiddleware = RequestMiddlewareWithTypes<any, any>\n\nexport interface RequestMiddlewareWithTypes<TMiddlewares, TServerContext> {\n  _types: RequestMiddlewareTypes<TMiddlewares, TServerContext>\n}\n\nexport interface RequestMiddlewareTypes<TMiddlewares, TServerContext> {\n  type: 'request'\n  middlewares: TMiddlewares\n  serverContext: TServerContext\n  allServerContext: AssignAllServerContext<\n    TMiddlewares,\n    undefined,\n    TServerContext\n  >\n}\n\nexport interface RequestMiddlewareAfterMiddleware<TMiddlewares>\n  extends RequestMiddlewareWithTypes<TMiddlewares, undefined>,\n    RequestMiddlewareServer<TMiddlewares> {}\n\nexport interface RequestMiddlewareServer<TMiddlewares> {\n  server: <TServerContext = undefined>(\n    fn: RequestServerFn<TMiddlewares, TServerContext>,\n  ) => RequestMiddlewareAfterServer<TMiddlewares, TServerContext>\n}\n\nexport type RequestServerFn<TMiddlewares, TServerContext> = (\n  options: RequestServerOptions<TMiddlewares>,\n) => RequestMiddlewareServerFnResult<TMiddlewares, TServerContext>\n\nexport interface RequestServerOptions<TMiddlewares> {\n  request: Request\n  pathname: string\n  context: AssignAllServerContext<TMiddlewares>\n  next: RequestServerNextFn<TMiddlewares>\n}\n\nexport type RequestServerNextFn<TMiddlewares> = <TServerContext = undefined>(\n  options?: RequestServerNextFnOptions<TServerContext>,\n) => RequestMiddlewareServerFnResult<TMiddlewares, TServerContext>\n\nexport interface RequestServerNextFnOptions<TServerContext> {\n  context?: TServerContext\n}\n\nexport type RequestMiddlewareServerFnResult<TMiddlewares, TServerContext> =\n  | Promise<RequestServerResult<TMiddlewares, TServerContext>>\n  | RequestServerResult<TMiddlewares, TServerContext>\n\nexport interface RequestServerResult<TMiddlewares, TServerContext> {\n  request: Request\n  pathname: string\n  context: Expand<\n    AssignAllServerContext<TMiddlewares, undefined, TServerContext>\n  >\n  response: Response\n}\n\nexport interface RequestMiddlewareAfterServer<TMiddlewares, TServerContext>\n  extends RequestMiddlewareWithTypes<TMiddlewares, TServerContext> {}\n", "import { HeadContent } from '@tanstack/react-router'\n\nexport const Meta = () => {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      'The Meta component is deprecated. Use `HeadContent` from `@tanstack/react-router` instead.',\n    )\n  }\n  return <HeadContent />\n}\n", "import { Scripts as RouterScripts } from '@tanstack/react-router'\n\nexport const Scripts = () => {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn('The Scripts component was moved to `@tanstack/react-router`')\n  }\n  return <RouterScripts />\n}\n", "import { Await, RouterProvider } from '@tanstack/react-router'\nimport { hydrate } from '@tanstack/start-client-core'\nimport type { AnyRouter } from '@tanstack/router-core'\n\nlet hydrationPromise: Promise<void | Array<Array<void>>> | undefined\n\nexport function StartClient(props: { router: AnyRouter }) {\n  if (!hydrationPromise) {\n    if (!props.router.state.matches.length) {\n      hydrationPromise = hydrate(props.router)\n    } else {\n      hydrationPromise = Promise.resolve()\n    }\n  }\n  return (\n    <Await\n      promise={hydrationPromise}\n      children={() => <RouterProvider router={props.router} />}\n    />\n  )\n}\n", "// TODO: RSCs\nimport { isValidElement } from 'react'\nimport invariant from 'tiny-invariant'\nimport type React from 'react'\n\nexport function renderRsc(input: any): React.JSX.Element {\n  if (isValidElement(input)) {\n    return input\n  }\n\n  if (typeof input === 'object' && !input.state) {\n    input.state = {\n      status: 'pending',\n      promise: Promise.resolve()\n        .then(() => {\n          let element\n\n          // We're in node\n          // TODO: RSCs\n          // if (reactDom.createFromNodeStream) {\n          //   const stream = await import('node:stream')\n\n          //   let body: any = input\n\n          //   // Unwrap the response\n          //   if (input instanceof Response) {\n          //     body = input.body\n          //   }\n\n          //   // Convert ReadableStream to NodeJS stream.Readable\n          //   if (body instanceof ReadableStream) {\n          //     body = stream.Readable.fromWeb(body as any)\n          //   }\n\n          //   if (stream.Readable.isReadable(body)) {\n          //     // body = copyStreamToRaw(body)\n          //   } else if (input.text) {\n          //     // create a readable stream by awaiting the text method\n          //     body = new stream.Readable({\n          //       async read() {\n          //         input.text().then((value: any) => {\n          //           this.push(value)\n          //           this.push(null)\n          //         })\n          //       },\n          //     })\n          //   } else {\n          //     console.error('input', input)\n          //     throw new Error('Unexpected rsc input type ')\n          //   }\n\n          //   element = await reactDom.createFromNodeStream(body)\n          // } else {\n          //   // We're in the browser\n          //   if (input.body instanceof ReadableStream) {\n          //     input = input.body\n          //   }\n\n          //   if (input instanceof ReadableStream) {\n          //     element = await reactDom.createFromReadableStream(input)\n          //   }\n\n          //   if (input instanceof Response) {\n          //     // copy to the response body to cache the raw data\n          //     element = await reactDom.createFromFetch(input)\n          //   }\n          // }\n\n          // return element\n\n          invariant(false, 'renderRSC() is coming soon!')\n        })\n        .then((element) => {\n          input.state.value = element\n          input.state.status = 'success'\n        })\n        .catch((err) => {\n          input.state.status = 'error'\n          input.state.error = err\n        }),\n    }\n  }\n\n  if (input.state.status === 'pending') {\n    throw input.state.promise\n  }\n\n  return input.state.value\n}\n", "import * as React from 'react'\nimport { isRedirect } from '@tanstack/router-core'\nimport { useRouter } from '@tanstack/react-router'\n\nexport function useServerFn<T extends (...deps: Array<any>) => Promise<any>>(\n  serverFn: T,\n): (...args: Parameters<T>) => ReturnType<T> {\n  const router = useRouter()\n\n  return React.useCallback(\n    async (...args: Array<any>) => {\n      try {\n        const res = await serverFn(...args)\n\n        if (isRedirect(res)) {\n          throw res\n        }\n\n        return res\n      } catch (err) {\n        if (isRedirect(err)) {\n          err.options._fromLocation = router.state.location\n          return router.navigate(router.resolveRedirect(err).options)\n        }\n\n        throw err\n      }\n    },\n    [router, serverFn],\n  ) as any\n}\n"],
  "mappings": "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",
  "names": ["_b", "_a", "_c", "serverFnStaticCache", "json", "Scripts", "RouterScripts"]
}
